import React, { useEffect, useState, useRef } from 'react';
import { Line } from 'react-chartjs-2';
import { Box } from '@material-ui/core';
import * as R from 'ramda';

import { metricObservables } from '../websocket';
import { MonitoringMetric } from '../models';
import { metricMinimum, labelFormatter } from '../util/monitoring';
import { metricLookup } from './MonitoringDialog';

const windowSize = 60;

const generateInitialPoints = () => {
    const currentDate: number = new Date().getTime() as number;

    const initialData: { x: Date, y: null | number }[] = Array(windowSize).fill(0).map((e, i) => ({
        x: new Date(currentDate - (windowSize - i) * 1000),
        y: null
    }));

    return initialData;
}

const muh = (metric: string) => ({
    datasets: [{
        label: metric,
        fill: false,
        lineTension: 0.1,
        backgroundColor: '#84329B',
        borderColor: '#84329B',
        borderCapStyle: 'butt',
        borderDash: [],
        borderDashOffset: 0.0,
        borderJoinStyle: 'miter',
        pointBorderColor: '#84329B',
        pointBackgroundColor: '#84329B',
        pointBorderWidth: 0,
        pointHoverRadius: 5,
        pointHoverBackgroundColor: 'rgba(75,192,192,1)',
        pointHoverBorderColor: 'rgba(220,220,220,1)',
        pointHoverBorderWidth: 2,
        pointRadius: 3,
        pointHitRadius: 10,
        data: generateInitialPoints()
    }]
});



interface MetricChartProps {
    metric: MonitoringMetric
}

const MetricChart: React.FC<MetricChartProps> = ({ metric }) => {
    const chartOptions = {
        title: {
            text: metricLookup[metric].label,
            display: true
        },
        responsive: true,
        maintainAspectRatio: false,
        legend: { display: false },
        tooltips: { enabled: false },
        hover: { mode: null },
        scales: {
            xAxes: [{
                type: 'time',
                ticks: { display: false },
                time: { unit: 'seconds' }
            }],
            yAxes: [{
                scaleLabel: false,
                ticks: {
                    suggestedMin: metricMinimum[metric],
                    callback: labelFormatter[metric]
                }
            }]
        }
    };

    const [chartData, setChartData] = React.useState(muh(metric as string));

    useEffect(() => {
        let metricSubscriber = metricObservables[metric].subscribe((event: any) => {
            console.log(`new event for ${metric}: ${event}`);
            const { measurement } = event;


            setChartData(cd => {
                const dataset = cd.datasets[0];
                const newDataset = { ...dataset };
                const newData = newDataset.data;

                newData.push({
                    x: new Date(measurement.timestamp * 1000),
                    y: measurement.value
                });
                newData.shift();

                console.log(newDataset);
                return {
                    ...cd,
                    datasets: [newDataset]
                }
            });

            console.log(chartData);
        });

        return () => {
            console.log(`unsubscribe ${metric}`);
            metricSubscriber.unsubscribe();
        };

    }, []);

    console.log("rerender");
    return (
        <Box width="100%">
            <Line options={chartOptions} data={chartData} key={metric} />
        </Box>
    );
}

export default MetricChart;
